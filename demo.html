<div style="display: flex; place-content: center; height: 5vh;     text-align: center;">

    <span>
        <span style="    font-weight: 600;
     font-size: larger;">NSDAI FaceRe </span> <br> Please focus on camera for Face Recognition.

    </span>
</div>

<div style="display: flex;justify-content: center;text-align: center;height: 90vh;">
    <div style="height: 80vh;overflow: hidden;border: 1px solid black;align-self: center;object-fit: cover;width: 40%;">
        <img src="https://i.stack.imgur.com/aFYTl.jpg?s=328&amp;g=1"
            style="width: 100%; height: 80%; object-fit: cover;">
        <div style="font-weight: 500; font-size:large; ">
            <h4>
                Name: <span class="h4" id="StudentName">Jonghun Kim</span>
                <br>
            </h4>
            <h4 class="h4">ID : <span class="h4" id="RollID">0082020C50123456</span></h4>
        </div>
    </div>
    <div style="width: 5%;"></div>

    <div style="width: 40%;-webkit-transform-origin-y: center;height: 80vh;place-self: center;border: 1px solid black;">
        <div style="position: relative; background-color: rgb(156, 198, 158);">
            <img id="FaceReFocusOverlay"
                src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iNjAwLjAwMDAwMHB0IiBoZWlnaHQ9IjUwMC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDYwMC4wMDAwMDAgNTAwLjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjE2LCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxOQo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCw1MDAuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjMDAwMDAwIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNMzIyIDQzMjcgbC0yIC0zODggNDMgMyA0MiAzIDMgMzQzIDIgMzQyIDI5NSAwIDI5NSAwIC0yIDQzIC0xIDQyCi00IC0zNyAtNCAtMzggLTI5MiAtMiAtMjkyIC0zIC0zIC0zNDIgLTIgLTM0MyAtMzUgMCAtMzUgMCAtMyAzODMgLTIgMzgyIC0zCi0zODh6Ii8+CjxwYXRoIGQ9Ik01MDEyIDQ2NzMgbC0yIC00MyAyOTUgMCAyOTUgMCAwIC0zNDUgMCAtMzQ1IDQ1IDAgNDUgMCAtMiAzODggLTMKMzg3IC0yIC0zODIgLTMgLTM4MyAtMzUgMCAtMzUgMCAtMiAzNDMgLTMgMzQyIC0yOTIgMyAtMjkyIDIgLTQgMzggLTQgMzcgLTEKLTQyeiIvPgo8cGF0aCBkPSJNMTUwMCAzNTI1IGMwIC0yMDggMSAtMjE1IDIwIC0yMTUgMTkgMCAyMCA3IDIwIDE5MCBsMCAxOTAgMTY4IDIKYzE2NSAzIDE2NyAzIDE3MCAyNiBsMyAyMiAtMTkwIDAgLTE5MSAwIDAgLTIxNXoiLz4KPHBhdGggZD0iTTQxMjAgMzcxNSBsMCAtMjUgMTcwIDAgMTcwIDAgMCAtMTkwIGMwIC0xODMgMSAtMTkwIDIwIC0xOTAgMTkgMAoyMCA3IDIwIDIxNSBsMCAyMTUgLTE5MCAwIC0xOTAgMCAwIC0yNXoiLz4KPHBhdGggZD0iTTI4NDMgMjkzMSBjLTE1MiAtNTUgLTI2OSAtMjAxIC0yOTIgLTM2NCAtMjcgLTE5MyA3MiAtMzg0IDI0NCAtNDY3Cjg5IC00MyAxMDUgLTQ2IDEwNSAtMjAgMCAxMSAtOCAyMyAtMTcgMjYgLTExMyAzNSAtMjA2IDExNiAtMjU2IDIyMSAtMzAgNjQKLTMyIDc1IC0zMiAxNzggMCAxMDQgMiAxMTQgMzMgMTc3IDUwIDEwMSAxMzIgMTc1IDI0NSAyMTcgMTcgNyAyNyAxOCAyNyAzMSAwCjExIC0xIDIwIC0yIDIwIC0yIC0xIC0yNiAtOSAtNTUgLTE5eiIvPgo8cGF0aCBkPSJNMzEwMCAyOTI5IGMwIC0xMiAxMCAtMjMgMjggLTMwIDExMSAtNDIgMTk0IC0xMTYgMjQ0IC0yMTcgMzEgLTYzCjMzIC03MiAzMyAtMTc3IDAgLTEwMyAtMiAtMTE0IC0zMiAtMTc4IC01MCAtMTA1IC0xNDMgLTE4NiAtMjU1IC0yMjEgLTEwIC0zCi0xOCAtMTUgLTE4IC0yNiAwIC0yNiAxNiAtMjMgMTA1IDIwIDIyMiAxMDcgMzExIDM3OSAyMDAgNjA2IC01MyAxMDggLTE2NAoyMDIgLTI3NSAyMzQgLTI2IDcgLTMwIDYgLTMwIC0xMXoiLz4KPHBhdGggZD0iTTE1MDAgMTQ4NSBsMCAtMjE1IDE5MCAwIGMxODMgMCAxOTAgMSAxOTAgMjAgMCAxOSAtOCAyMCAtMTY3IDIyCmwtMTY4IDMgLTMgMTkzIGMtMiAxODQgLTMgMTkyIC0yMiAxOTIgLTE5IDAgLTIwIC03IC0yMCAtMjE1eiIvPgo8cGF0aCBkPSJNNDQ1OCAxNTA4IGwtMyAtMTkzIC0xNjcgLTMgYy0xNjAgLTIgLTE2OCAtMyAtMTY4IC0yMiAwIC0xOSA3IC0yMAoxOTAgLTIwIGwxOTAgMCAwIDIxNSBjMCAyMDggLTEgMjE1IC0yMCAyMTUgLTE5IDAgLTIwIC04IC0yMiAtMTkyeiIvPgo8cGF0aCBkPSJNMzIwIDY4MSBsMCAtMzkxIDM0MCAwIDM0MCAwIDAgNDUgMCA0NSAtMjk1IDAgLTI5NSAwIC0yIDM0MyAtMyAzNDIKLTQyIDMgLTQzIDMgMCAtMzkweiBtODAgMzQgbDAgLTM0NSAyOTUgMCAyOTUgMCAwIC0zNSAwIC0zNSAtMzMwIDAgLTMzMCAwIDAKMzgwIDAgMzgwIDM1IDAgMzUgMCAwIC0zNDV6Ii8+CjxwYXRoIGQ9Ik01NjA3IDEwNjMgYy00IC0zIC03IC0xNTkgLTcgLTM0NSBsMCAtMzM4IC0yOTUgMCAtMjk1IDAgMCAtNDUgMAotNDUgMzQwIDAgMzQwIDAgMCAzOTAgMCAzOTAgLTM4IDAgYy0yMSAwIC00MiAtMyAtNDUgLTd6IG03MyAtMzgzIGwwIC0zODAKLTMzMCAwIC0zMzAgMCAwIDM1IDAgMzUgMjk1IDAgMjk1IDAgMCAzNDUgMCAzNDUgMzUgMCAzNSAwIDAgLTM4MHoiLz4KPC9nPgo8L3N2Zz4K"
                style="position: absolute; width: -webkit-fill-available; height: 100%;">

            <video class="input_video" style="width: 100%; place-self: center; object-fit: cover; height: 80%;"
                src=""></video>
        </div>

        <div style="font-weight: 500; font-size: large; width:100% ">
            <br>
            <button id="RetakeButton" style="width: 45%;    height: 4em; display: none;" onclick="retake()">üîÅ<br>
                Retake </button>
            <button id="SubmitButton" style="width: 45%;     height: 4em;display: none;"> ‚úîÔ∏è <br> Submit </button>
            <div style="    padding-top: .6em;">Match : <span class="font-weight: 500; font-size:large; "
                    id="matchPercentage"> Loading ... .
                </span>
                </h4>

            </div>
        </div>
    </div>

</div>



<!-- <script src="https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/dist/face-api.js"></script> -->

<script>
    /**
     * Fetch Inject module.
     *
     * @module fetchInject
     * @license Zlib
     * @param {(USVString[]|Request[])} inputs Resources you wish to fetch.
     * @param {Promise} [promise] A promise to await before attempting injection.
     * @throws {Promise<ReferenceError>} Rejects with error when given no arguments.
     * @throws {Promise<TypeError>} Rejects with error on invalid arguments.
     * @throws {Promise<Error>} Whatever `fetch` decides to throw.
     * @throws {SyntaxError} Via DOM upon attempting to parse unexpected tokens.
     * @returns {Promise<Object[]>} A promise which resolves to an `Array` of
     *     Objects containing `Response` `Body` properties used by the module.
     */
    injectHead = function (i, n, j, e, c, t, s) {
        (t = n.createElement(j)), (s = n.getElementsByTagName(j)[0]);
        t.appendChild(n.createTextNode(e.text));
        t.onload = c(e);
        s ? s.parentNode.insertBefore(t, s) : n.head.appendChild(t);
    }; // eslint-disable-line
    fetchInject = function (inputs, promise) {
        if (!arguments.length) return Promise.reject(new ReferenceError("Failed to execute 'fetchInject': 1 argument required but only 0 present."));
        if (arguments[0] && arguments[0].constructor !== Array) return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 1 must be of type 'Array'."));
        if (arguments[1] && arguments[1].constructor !== Promise) return Promise.reject(new TypeError("Failed to execute 'fetchInject': argument 2 must be of type 'Promise'."));

        const resources = [];
        const deferreds = promise ? [].concat(promise) : [];
        const thenables = [];

        inputs.forEach((input) =>
            deferreds.push(
                window
                    .fetch(input)
                    .then((res) => {
                        return [res.clone().text(), res.blob()];
                    })
                    .then((promises) => {
                        return Promise.all(promises).then((resolved) => {
                            resources.push({ text: resolved[0], blob: resolved[1] });
                        });
                    })
            )
        );

        return Promise.all(deferreds).then(() => {
            resources.forEach((resource) => {
                thenables.push({
                    then: (resolve) => {
                        resource.blob.type.includes("text/css") ? injectHead(window, document, "style", resource, resolve) : injectHead(window, document, "script", resource, resolve);
                    },
                });
            });
            return Promise.all(thenables);
        });
    };

    // this is the Camera Input
    const videoElement = document.getElementsByClassName("input_video")[0];

    //
    loadLibraries = fetchInject([
        "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1631210127/camera_utils.js",
        "https://cdn.jsdelivr.net/npm/deepcopy@2.1.0/umd/deepcopy.min.js",
        "https://cdn.jsdelivr.net/npm/capture-video-frame@1.0.0/capture-video-frame.min.js",
        "https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/dist/face-api.js",
        // "https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js",
        // "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js",
        // "https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/face_detection.js",
    ]);

    async function requestExternalImage(imageData) {
        const imageUrl = imageData[1];
        const res = await fetch(imageUrl);
        if (!(res.status < 400)) {
            console.error(res.status + " : " + (await res.text()));
            throw new Error("failed to fetch image from url: " + imageUrl);
        }

        let blob;
        try {
            blob = await res.blob();
            return await [imageData[0], imageData[1], await faceapi.bufferToImage(blob)];
        } catch (e) {
            console.error("received blob:", blob);
            console.error("error:", e);
            throw new Error("failed to load image from url: " + imageUrl);
        }
    }

    ImageUrls = {
        "self_1": "https://images.generated.photos/NQv6Dt_7n6IiEPue6OJro2q52quDwWrcfxLobYlT8Oc/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/NDY4Mjg0LmpwZw.jpg",
        "self_2": "https://images.generated.photos/OuQAZkglgbQufjOKgCF3RdTIXMr73RHACuHYXorW6JQ/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/NzA3MjY0LmpwZw.jpg",
        "self_3": "https://images.generated.photos/rEtZIf1Lx1awn9Y9ZZBTzqi2Kx-VMPQRtJx_jExvlzE/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/OTE4MTU5LmpwZw.jpg",
        "4": "https://images.generated.photos/W1-nFy63WDv1T1w64D7X92rMdeVec1n6gfXtqVsoZU0/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/Mzk5NDM1LmpwZw.jpg",
        "5": "https://i.ibb.co/vhV4KLm/Untitled.png",
        "ugly": "https://i.imgflip.com/q0azh.jpg",
        "HDD": "https://5.imimg.com/data5/CI/KY/ER/SELLER-13508457/computer-hard-disk-500x500.jpeg",
        "blank": "data:image/gif;base64,R0lGODlhAQABAIAAAP7//wAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==",
        // "d": 'hsttps://images.generated.photos/W1-nFy63WDv1T1w64D7X92rMdeVec1n6gfXtqVsoZU0/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/Mzk5NDM1LmpwZw.jpg',
        // "g": 'https://images.generated.photos/W1-nFy63WDv1T1w64D7X92rMdeVec1n6gfXtqVsoZU0/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92ssM18w/Mzk5NDM1LmpwZw.jpg',
    };

    //collect descriptors of all in the list
    ImageDescriptors = null;
    FaceRecamera = null;
    GetImagedescriptor = Promise.allSettled([loadLibraries]).then(() => ([console.log("FaceRe Model loading. . "),
    faceapi.nets.tinyFaceDetector.loadFromUri("https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights"),
    faceapi.nets.faceLandmark68Net.loadFromUri("https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights"),
    faceapi.nets.faceRecognitionNet.loadFromUri("https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights"),
    // faceapi.nets.faceExpressionNet.loadFromUri("/static/models"),
    faceapi.nets.ssdMobilenetv1.loadFromUri("https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@0.22.2/weights"),
    ])).then(() => {
        return Promise.all(
            Object.entries(ImageUrls).map(async (entry) => {
                return await requestExternalImage(entry);
            })
        );
    })
        .then((ImagesBlobs) => {
            // console.log('Images Blobs: ', ImagesBlobs)
            // console.log('Images Blobs: ', ImagesBlobs.length)

            return Promise.all(
                ImagesBlobs.map(async (imageData) => {
                    const detections = await faceapi.detectSingleFace(imageData[2], new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();
                    // debugger
                    return {
                        imageid: imageData[0],
                        imageUrl: imageData[1],
                        imageData: imageData[2],
                        detections: (typeof detections === "undefined") ? new Array(128).fill(0) : detections.descriptor,
                    };
                })
            );
        })
        .then((ImgeDescriptors) => {
            // console.log("Image Descriptors: ", ImgeDescriptors);
            ImageDescriptors = ImgeDescriptors
            return ImageDescriptors;
        });

    lastUpdateTime = new Date().getTime();
    interval = 100;
    //when descriptor is ready and all dependecies are loaded
    Promise.allSettled([GetImagedescriptor]).then(() => {
        //Get Camera and start
        FaceRecamera = new Camera(videoElement, {
            onFrame: async () => {
                if (((new Date().getTime()) - lastUpdateTime > interval)) {
                    result = await HandleNewFrame({ image: videoElement });
                    if (typeof result !== "undefined") HandleResults(result);
                    lastUpdateTime = new Date().getTime();
                }
                // alert('hi')

            },
            width: 1280,
            height: 720,
        });

        FaceRecamera.start();
    });

    detectionResults = null;
    async function HandleNewFrame(frame) {
        const detections = await faceapi.detectSingleFace(frame.image, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();
        if (typeof detections !== "undefined") {
            distances = ImageDescriptors.map((each) => {
                each["distance"] = faceapi.euclideanDistance(each.detections, detections.descriptor);
                return each
            });
            // console.log(distances);

            return distances;
        }
    }

    const framesToRecord = 10
    function HandleResults(results) {

        if (detectionResults === null) detectionResults = []

        // console.log("HandleResults: ", results, detectionResults.length);


        if (detectionResults.length < framesToRecord) {
            detectionResults.push(deepcopy(results))

            FaceReFocusOverlay = document.getElementById("FaceReFocusOverlay")
            FaceReFocusOverlay.style.display = 'block'

            setTimeout(function () {
                FaceReFocusOverlay.style.display = 'none'
            }, 1000);

            result = PrepareResults()

            if (detectionResults.length === framesToRecord) {
                // console.log(framesToRecord, " frames recorded")
                //handle predictions
                FrameCollectionCompleted(result)
            }
        }

        else if (detectionResults.length === framesToRecord) {
            //
            // console.log("ignored")
        }

    }

    function PrepareResults() {
        result2d = detectionResults.map((each) => {
            return each.map((each2) => {
                return parseFloat(each2.distance)
            })
        })

        let columnAverage = result2d.reduce((acc, cur) => {
            cur.forEach((e, i) => acc[i] = acc[i] ? acc[i] + e : e);
            return acc;
        }, []).map(e => e / result2d.length);
        //find maximum index
        minimumAverage = columnAverage.reduce((m, n) => Math.min(m, n))
        coumnNumber = columnAverage.indexOf(minimumAverage)
        column = result2d.map(function (e) { return e[coumnNumber] })
        minScore = Math.min.apply(null, column)
        rownumber = column.indexOf(minScore)


        inverted = 100 - minimumAverage * 100 + 15 //15 is added threshold
        if (inverted >= 100) inverted = 99 //if max out due to added threshold set to 99
        if (inverted <= 0) inverted = 0 //if min out due to any problem set to 0 
        document.getElementById('matchPercentage').innerHTML = Math.ceil(inverted) + "%"


        return [inverted, detectionResults[rownumber][coumnNumber]]

    }


    function FrameCollectionCompleted(bestResult) {

        document.getElementsByClassName("input_video")[0].pause()
        document.getElementById("RetakeButton").style.display = ''
        document.getElementById("SubmitButton").style.display = ''

        ImageURI = captureVideoFrame(document.getElementsByClassName("input_video")[0], "jpeg", 0.95).dataUri
        // debugger
        output = {
            "AvgScore": bestResult[0],
            "LatestImageURI": ImageURI,
            "BestMatch": {
                id: bestResult[1].imageid,
                imageUrl: bestResult[1].imageUrl,
                rawScore: bestResult[1].distance
            }, "rawDetectionResults": detectionResults

        }
        console.log(output)
        return output
    }

    function retake() {
        document.getElementsByClassName("input_video")[0].play()
        detectionResults = null

    }



</script>